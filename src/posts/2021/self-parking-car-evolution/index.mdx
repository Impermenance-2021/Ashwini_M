---

title: "Self-Parking Car in <500 Lines of Code"

summary: "Training the car to do self-parking using a genetic algorithm"

cover: assets/01-cover-00.jpg

date: 2021-09-18

---

![Self-Parking car evolution](assets/01-cover-01.jpg)

## TL;DR

In this article we'll train the car to do self-parking using a [genetic algorithm](https://en.wikipedia.org/wiki/Genetic_algorithm).

We'll create **the 1st generation** of cars with random genomes that will behave something like this:

![The 1st generation of cars with random genomes](assets/02-cars-before-01.gif)

**On the ≈40th generation** the cars start learning what the self-parking is and start getting closer to the parking spot:

![The 40th generation start learning how to park](assets/03-car-after-01.gif)

Another example with a bit more challenging starting point:

![More challenging starting point for self-parking](assets/03-car-after-03.gif)

> Yeah-yeah, the cars are hitting some other cars along the way, bit this is only the 40th generation since the creation of the world for them, so be merciful and give them some space to grow :D

You may launch the 🚕 [Self-parking Car Evolution Simulator](https://trekhleb.dev/self-parking-car-evolution) to see the evolution process directly in you browser. The simulator gives you the following opportunities:

- You may [train the cars from scratch](https://trekhleb.dev/self-parking-car-evolution?parking=evolution#/) and adjust genetic parameters by yourself
- You may [see the trained self-parking cars in action](https://trekhleb.dev/self-parking-car-evolution?parking=automatic#/)
- You may also [try to park the car manually](https://trekhleb.dev/self-parking-car-evolution?parking=manual#/).

The genetic algorithm for this project is implemented in TypeScript. The full genetic source code will be shown in this article, but you may also find the final code examples in the [Evolution Simulator repository](https://github.com/trekhleb/self-parking-car-evolution).

> We're going to use a genetic algorithm for particular task of evolving cars genomes. However, this article only touches on the basics of the algorithm and is by no means a complete guide to the genetic algorithm topic.

Having that said, let's deep dive into more details...

## The Plan

Here is what we're going to do:

1. 💪🏻 Give the **muscles** (engine, steering wheel) to the car so that it could move towards the parking lot.
2. 👀 Give the **eyes** (sensors) to the car so that they could see the obstacles around.
3. 🧠 Give the **brain** to the car that will control the muscles (movements) based on what car sees (obstacles via sensors). The brain is simply a pure function `movements = f(sensors)`.
4. 🧬 **Evolve/teach the brain** to do the right moves based on the sensors input. This is where we will apply a genetic algorithm. Generation after generation our brain function `movements = f(sensors)` will learn how to move the car towards the parking lot.

## Giving the muscles to the car

To be able to move, the car would need "muscles". Let's give the car two types of muscles:

1. **Engine muscle** - allows the car to move *↓ back*, *↑ forth*, or *◎ stand steel* (neutral gear)
2. **Steering wheel muscle** - allows the car to turn *← left*, *→ right*, or *◎ go straight* while moving

With these two muscles the car is able to perform the following movements:

![Car movements achieved by car muscles](assets/03-car-muscles-01.gif)

In our case, the muscles are receivers of the signals that comes from the brain once every `100ms` (milliseconds). Based on the value of the brain's signal the muscles acts differently. We'll cover the "brain" part below, but for now, let's say that our brain may send only 3 possible signals to each muscle: `-1`, `0`, or `+1`.

```typescript
type MuscleSignal = -1 | 0 | 1;
```

For example, the brain may send the signal with the value of `+1` to the engine muscle and it will start moving the car forward. The signal `-1` to the engine moves the car backward. At the same time, if the brain will send the signal of `-1` to the steering wheel muscle, it will turn the car to the left, etc.

Here is how the brain signal values map to the muscle actions in our case:

| Muscle             | `Signal = -1` | `Signal = 0` | `Signal = +1` |
| :----------------- | :------------ | :----------- | :------------ |
| **Engine**         | ↓ Backward    | ◎ Neutral    | ↑ Forward     |
| **Steering wheel** | ← Left        | ◎ Straight   | → Right       |

> You may [use the Evolution Simulator](https://trekhleb.dev/self-parking-car-evolution?parking=manual#/) and try to park the car manually to see how car muscles work. Every time you press one of the `WASD` buttons (or use a joystick) you send these `-1`, `0` or `+1` signals to the engine and steering wheel muscles.

## Giving the eyes to the car

Before our car will learn how to do self-parking using its muscles, it needs to be able to "see" the surroundings. Let's give it the `8` eyes in a form of distance sensors:

- Each sensor can detect the obstacle in a distance range of `0-4m` (meters).
- Each sensor reports the latest information about the obstacles it "sees" to the car's "brain" every `100ms`.
- Whenever the sensor doesn't see any obstacles it reports the value of `0`. On the contrary, if the value of the sensor is small but not zero (i.e. `0.01m`) it would mean that the obstacle is really close.

![Car sensors with distances](assets/04-sensors-01.jpg)

> You may [use the Evolution Simulator](https://trekhleb.dev/self-parking-car-evolution?parking=manual#/) and see how the color of each sensor changes based on how close the obstacle is.

```typescript
type Sensors = number[];
```

## Giving the brain to the car

At this moment, our car can "see" and "move", but there is no "coordinator", that would transform the signals from the "eyes" to the proper movements of the "muscles". We need to give the car a "brain".

### Brain input

As an input from the sensors, every `100ms` the brain will be getting `8` float numbers, each one in range of `[0...4]`. For example, the input might look like this:

```typescript
const sensors: Sensors = [s0, s1, s2, s3, s4, s5, s6, s7];
// i.e. 🧠 ← [0, 0.5, 4, 0.002, 0, 3.76, 0, 1.245]
```

### Brain output

Every `100ms` the brain should produce two integers as an output:

1. One number as a signal for the engine: `engineSignal`
2. One number as signal for the steering wheel: `wheelSignal`

Each number should be of a type `MuscleSignal` and might take one of three values: `-1`, `0`, or `+1`.

### Brain formulas/functions

Keeping in mind the brain's input and output mentioned above we may say that the brain is just a function:

```typescript
const { engineSignal, wheelSignal } = brainToMuscleSignal(
  brainFunction(sensors)
);
// i.e. { engineSignal: 0, wheelSignal: -1 } ← 🧠 ← [0, 0.5, 4, 0.002, 0, 3.76, 0, 1.245]
```

Where `brainToMuscleSignal()` is a function that converts raw brain signals (any float number) to muscle signals (to  `-1`, `0`, or `+1` number) so that muscles could understand it. We'll implement this converter function below.

The main question now is what kind of function the `brainFunction()` is.

To make the car smarter and its movements to be more sophisticated we could go with a [Multilayer Perceptron](https://en.wikipedia.org/wiki/Multilayer_perceptron). The name is a bit scary but this is a simple Neural Network with a basic architecture (think of it as of a big formula with many parameters/coefficients).

> I've covered Multilayer Perceptrons with a bit more details in my [homemade-machine-learning](https://github.com/trekhleb/homemade-machine-learning#-multilayer-perceptron-mlp), [machine-learning-experiments](https://github.com/trekhleb/machine-learning-experiments#multilayer-perceptron-mlp-or-simple-neural-network-nn), and [nano-neuron](https://github.com/trekhleb/nano-neuron) projects. You may even challenge that simple network [to recognize your written digits](https://trekhleb.dev/machine-learning-experiments/#/experiments/DigitsRecognitionMLP).

However, to avoid the introduction of a whole new concept of Neural Networks, we'll go with a much simpler approach and we'll use two **Linear Polynomials** with multiple variables (to be more precise, each polynomial will have exactly `8` variables, since we have `8` sensors) which will look something like this:

```typescript
engineSignal = brainToMuscleSignal(
  (e0 * s0) + (e1 * s1) + ... + (e7 * s7) + e8 // <- brainFunction
)

wheelSignal = brainToMuscleSignal(
  (w0 * s0) + (w1 * s1) + ... + (w7 * s7) + w8 // <- brainFunction
)
```

Where:

- `[s0, s1, ..., s7]` - the `8` variables (`8` sensor values). These ones are dynamic.
- `[e0, e1, ..., e8]` - the `9` coefficients for the engine polynomial. These ones the car will need to learn, and they will be static.
- `[w0, w1, ..., w8]` - the `9` coefficients for the steering wheel polynomial. These ones the car will need to learn, and they will be static

The cost of using the simpler function for the brain will be that the car won't be able to learn some sophisticated moves and also won't be able to generalize well and to adopt well to the unknown surroundings. But for our particular parking lot and for the sake of demonstrating the work of a genetic algorithm it should still be enough.

We may implement the generic polynomial function in the following way:

```typescript
type Coefficients = number[];

// Calculates the value of a linear polynomial based on the coefficients and variables.
const linearPolynomial = (coefficients: Coefficients, variables: number[]): number => {
  if (coefficients.length !== (variables.length + 1)) {
    throw new Error('Incompatible number of polynomial coefficients and variables');
  }
  let result = 0;
  coefficients.forEach((coefficient: number, coefficientIndex: number) => {
    if (coefficientIndex < variables.length) {
      result += coefficient * variables[coefficientIndex];
    } else {
      // The last coefficient needs to be added up without multiplication.
      result += coefficient
    }
  });
  return result;
};
```

The car's brain in this case will consist of two polynomials and will look like this:

```typescript
const engineSignal: MuscleSignal = brainToMuscleSignal(
  linearPolynomial(engineCoefficients, sensors)
);

const wheelSignal: MuscleSignal = brainToMuscleSignal(
  linearPolynomial(wheelCoefficients, sensors)
);
```

The output of a `linearPolynomial()` function is a float number. The `brainToMuscleSignal()` function need to convert the wide range of floats to three particular integers, and it will do it in two steps:

1. Convert the float of a wide range (i.e. `0.456` or `3673.45` or `-280`) to the float in a range of `(0...1)` (i.e. `0.05` or `0.86`)
2. Convert the float in a range of `(0...1)` to one of three integer values of `-1`, `0`, or `+1`. For example, the floats that are close to `0` will be converted to `-1`, the floats that are close to `0.5` will be converted to `0`, and the floats that are close to `1` will be converted to `1`.

To do the first part of the conversion we need to introduce a [Sigmoid Function](https://en.wikipedia.org/wiki/Sigmoid_function) which implements the following formula:

![Sigmoid formula](assets/05-sigmoid-01.svg)

It converts the wide range of floats (the `x` axis) to float numbers with a limited range of `(0...1)` (the `y` axis). This is exactly what we need.

![Sigmoid graph](assets/05-sigmoid-02.png)

Here is how the conversion steps would look on the Sigmoid graph.

![Conversion steps on the graph](assets/05-sigmoid-03.png)

The implementation of two conversion steps mentioned above would look like this:

```typescript
// Calculates the sigmoid value for a given number.
const sigmoid = (x: number): number => {
  return 1 / (1 + Math.E ** -x);
};

// Converts sigmoid value (0...1) to the muscle signals (-1, 0, +1)
// The margin parameter is a value between 0 and 0.5:
// [0 ... (0.5 - margin) ... 0.5 ... (0.5 + margin) ... 1]
const sigmoidToMuscleSignal = (sigmoidValue: number, margin: number = 0.4): MuscleSignal => {
  if (sigmoidValue < (0.5 - margin)) {
    return -1;
  }
  if (sigmoidValue > (0.5 + margin)) {
    return 1;
  }
  return 0;
};

// Converts raw brain signal to the muscle signal.
const brainToMuscleSignal = (rawBrainSignal: number): MuscleSignal => {
  const normalizedBrainSignal = sigmoid(rawBrainSignal);
  return sigmoidToMuscleSignal(normalizedBrainSignal);
}
```

## Car's genome (DNA)

> ☝🏻 The main conclusion from the "Eyes", "Muscles" and "Brain" sections above should be this: the coefficients `[e0, e1, ..., e8]` and `[w0, w1, ..., w8]` define the behavior of the car. These `18` numbers together form the unique car's Genome (or car's DNA).

### Car genome in a decimal form

Let's join the `[e0, e1, ..., e8]` and `[w0, w1, ..., w8]` brain coefficients together to form a car's genome in a decimal form:

```typescript
// Car genome as a list of decimal numbers (coefficients).
const carGenomeBase10 = [e0, e1, ..., e8, w0, w1, ..., w8];

// i.e. carGenomeBase10 = [17.5, 0.059, -46, 25, 156, -0.085, -0.207, -0.546, 0.071, -58, 41, 0.011, 252, -3.5, -0.017, 1.532, -360, 0.157]
```

### Car genome in a binary form

Let's move one step deeper (to the genes level) and convert the decimal numbers of the car's genome to the binary format (to the plain `1`s and `0`s).

> I've described in the details the process of converting the floating point numbers to the binary numbers in the [Binary representation of the floating-point numbers](https://trekhleb.dev/blog/2021/binary-floating-point/) article. You might want to check it out if the code in this section is not clear.

Here is a quick example of how the floating point number may be converted to the `16 bits` binary number (again, feel free to [read this first](https://trekhleb.dev/blog/2021/binary-floating-point/) if the example is confusing):

![Example of floating to binary numbers conversion](assets/06-floating-point-conversion-01.png)

In our case, to reduce the genome length, we will convert each floating coefficient to the non-standard `10 bits` binary number (`1` sign bit, `4` exponent bits, `5` fraction bits).

We have `18` coefficients in total, every coefficient will be converted to `10` bits number. It means that the car's genome will be an array of `0`s and `1`s with a length of `18 * 10 = 180 bits`.

For example, for the genome in a decimal format that was mentioned above, its binary representation would look like this:

```typescript
type Gene = 0 | 1;

type Genome = Gene[];

const genome: Genome = [
  // Engine coefficients.
  0, 1, 0, 1, 1, 0, 0, 0, 1, 1, // <- 17.5
  0, 0, 0, 1, 0, 1, 1, 1, 0, 0, // <- 0.059
  1, 1, 1, 0, 0, 0, 1, 1, 1, 0, // <- -46
  0, 1, 0, 1, 1, 1, 0, 0, 1, 0, // <- 25
  0, 1, 1, 1, 0, 0, 0, 1, 1, 1, // <- 156
  1, 0, 0, 1, 1, 0, 1, 1, 0, 0, // <- -0.085
  1, 0, 1, 0, 0, 1, 0, 1, 0, 1, // <- -0.207
  1, 0, 1, 1, 0, 0, 0, 0, 1, 1, // <- -0.546
  0, 0, 0, 1, 1, 0, 0, 1, 0, 0, // <- 0.071

  // Wheels coefficients.
  1, 1, 1, 0, 0, 1, 1, 0, 1, 0, // <- -58
  0, 1, 1, 0, 0, 0, 1, 0, 0, 1, // <- 41
  0, 0, 0, 0, 0, 0, 1, 0, 1, 0, // <- 0.011
  0, 1, 1, 1, 0, 1, 1, 1, 1, 1, // <- 252
  1, 1, 0, 0, 0, 1, 1, 0, 0, 0, // <- -3.5
  1, 0, 0, 0, 1, 0, 0, 1, 0, 0, // <- -0.017
  0, 0, 1, 1, 1, 1, 0, 0, 0, 1, // <- 1.532
  1, 1, 1, 1, 1, 0, 1, 1, 0, 1, // <- -360
  0, 0, 1, 0, 0, 0, 1, 0, 0, 0, // <- 0.157
];
```

Oh my! The binary genome looks so cryptic. But can you imagine, that these `180` zeroes and ones alone define how the car behaves on the parking lot! It's like you hacked someone's DNA and know what each gene means exactly. Amazing!

Here is the source code that performs the conversion from binary to decimal format for the floating point numbers:

```typescript
type Bit = 0 | 1;

type Bits = Bit[];

type PrecisionConfig = {
  signBitsCount: number,
  exponentBitsCount: number,
  fractionBitsCount: number,
  totalBitsCount: number,
};

export type PrecisionConfigs = {
  custom: PrecisionConfig,
};

export const precisionConfigs: PrecisionConfigs = {
  // Custom-made 10-bits precision for faster evolution progress.
  custom: {
    signBitsCount: 1,
    exponentBitsCount: 4,
    fractionBitsCount: 5,
    totalBitsCount: 10,
  },
};

// Converts the binary representation of the floating point number to decimal float number.
function bitsToFloat(bits: Bits, precisionConfig: PrecisionConfig): number {
  const { signBitsCount, exponentBitsCount } = precisionConfig;

  // Figuring out the sign.
  const sign = (-1) ** bits[0]; // -1^1 = -1, -1^0 = 1

  // Calculating the exponent value.
  const exponentBias = 2 ** (exponentBitsCount - 1) - 1;
  const exponentBits = bits.slice(signBitsCount, signBitsCount + exponentBitsCount);
  const exponentUnbiased = exponentBits.reduce(
    (exponentSoFar: number, currentBit: Bit, bitIndex: number) => {
      const bitPowerOfTwo = 2 ** (exponentBitsCount - bitIndex - 1);
      return exponentSoFar + currentBit * bitPowerOfTwo;
    },
    0,
  );
  const exponent = exponentUnbiased - exponentBias;

  // Calculating the fraction value.
  const fractionBits = bits.slice(signBitsCount + exponentBitsCount);
  const fraction = fractionBits.reduce(
    (fractionSoFar: number, currentBit: Bit, bitIndex: number) => {
      const bitPowerOfTwo = 2 ** -(bitIndex + 1);
      return fractionSoFar + currentBit * bitPowerOfTwo;
    },
    0,
  );

  // Putting all parts together to calculate the final number.
  return sign * (2 ** exponent) * (1 + fraction);
}

// Converts the 8-bit binary representation of the floating point number to decimal float number.
export function bitsToFloat10(bits: Bits): number {
  return bitsToFloat(bits, precisionConfigs.custom);
}
```

### Car genome summary

> ☝🏻 So, finally, we've got to the point when the problem of making the car to be a self-parking car is broken down to the problem of finding the best combination of `180` ones and zeros (basically, finding the "good-enough" genome). Sounds simple, doesn't it?

**Naive approach**

We could approach the problem of finding the "good-enough" genome in a naive way and try out all possible combinations of genes:

1. `[0, ..., 0, 0]`, and then...
2. `[0, ..., 0, 1]`, and then...
3. `[0, ..., 1, 0]`, and then...
4. `[0, ..., 1, 1]`, and then...
5. ...

But, let's do some math. With `180` bits and with each bit being equal either to `0` or to `1` we would have `2^180` (or `1.53 * 10^54`) possible combinations. Let's say we would need to give `15s` to each car to see if it will park successfully or not. Let's also say that we may run a simulation for `10` cars at once. Then we would need `15 * (1.53 * 10^54) / 10 = 2.29 * 10^54 [seconds]` which is `7.36 * 10^46 [years]`. Pretty long waiting time. Just as a side thought, it is only `2.021 * 10^3 [years]` have passed after Christ was born.

**Genetic approach**

We need a faster algorithm to find the optimal value of the genome. This is when the **Genetic Algorithm** comes to the rescue. We might not find the best value of the genome, but there is a chance that we may find the optimal value of it. And, what is more importantly, we don't need to wait that long. With the [Evolution Simulator](https://trekhleb.dev/self-parking-car-evolution) I was able to find a pretty good genomes within `24 [hours]`.

## Genetic algorithm basics

## Evolving the car's brain using a Genetic Algorithm

When we say that the car will evolve and learn how to do the self-parking, we mean that the car will figure out the "good-enough" values for these `18` coefficients, that will help it to do the parking based on the surroundings.

