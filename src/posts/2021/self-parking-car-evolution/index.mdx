---

title: "Self-Parking Car in <500 Lines of Code"

summary: "Training the car to do self-parking using a genetic algorithm"

cover: assets/01-cover-00.jpg

date: 2021-09-18

---

![Self-Parking car evolution](assets/01-cover-01.jpg)

## TL;DR

In this article we'll train the car to do self-parking using a [genetic algorithm](https://en.wikipedia.org/wiki/Genetic_algorithm).

We'll create **the 1st generation** of cars with random genomes that will behave something like this:

![The 1st generation of cars with random genomes](assets/02-cars-before-01.gif)

**On the ‚âà40th generation** the cars start learning what the self-parking is and start getting closer to the parking spot:

![The 40th generation start learning how to park](assets/03-car-after-01.gif)

Another example with a bit more challenging starting point:

![More challenging starting point for self-parking](assets/03-car-after-03.gif)

> Yeah-yeah, the cars are hitting some other cars along the way, bit this is only the 40th generation since the creation of the world for them, so be merciful and give them some space to grow :D

You may launch the üöï [Self-parking Car Evolution Simulator](https://trekhleb.dev/self-parking-car-evolution) to see the evolution process directly in you browser. The simulator gives you the following opportunities:

- You may [train the cars from scratch](https://trekhleb.dev/self-parking-car-evolution?parking=evolution#/) and adjust genetic parameters by yourself
- You may [see the trained (almost) self-parking cars in action](https://trekhleb.dev/self-parking-car-evolution?parking=automatic#/)
- You may also [try to park the car manually](https://trekhleb.dev/self-parking-car-evolution?parking=manual#/).

The genetic algorithm for this project is implemented in TypeScript. The full genetic source code will be shown in this article, but you may also find the final code examples in the [Evolution Simulator repository](https://github.com/trekhleb/self-parking-car-evolution).

> ‚ÑπÔ∏è We're going to use a genetic algorithm for particular task of evolving cars genomes. However, this article only touches on the basics of the algorithm and is by no means a complete guide to the genetic algorithm topic.

Having that said, let's deep dive into more details...

## Giving the muscles to the car

To be able to move, the car would need "muscles". Let's give the car two types of muscles:

1. **Engine muscle** - allows the car to move *‚Üì back*, *‚Üë forth*, or *‚óé stand steel* (neutral)
2. **Steering wheel muscle** - allows the car to turn *‚Üê left*, *‚Üí right*, or *‚óé go straight* while moving

With these two muscles the car is able to perform the movements like these:

![Car movements achieved by car muscles](assets/03-car-muscles-01.gif)

> You may [use the Evolution Simulator](https://trekhleb.dev/self-parking-car-evolution?parking=manual#/) and try to park the car manually to see how the car muscles work.

In our case, the muscles are receivers of the signals that comes from the brain once every `100ms`. Based on the value of the brain's signal the muscles acts differently. We'll cover the "brain" part below, but for now, let's say that our brain may send a signal that is just a `float` number in a range of `[0...1]` (i.e. `0`, or `0.945`, etc.).

For example, the brain may send the signal with the value of `0.992` (close to `1`) to the engine muscle and it will start moving the car forward. At the same time, if the brain will send the signal of `0.0002` (close to `0`) to the steering wheel muscle, it will turn the car to the left.

Here is how the brain signal values map to the muscle actions in our case:

| Muscle \ `Signal`  | `‚âà 0`      | `‚âà 0.5`     | `‚âà 1`      |
| :----------------- | :--------- | :---------- | :--------- |
| **Engine**         | ‚Üë Forward  | ‚óé Neutral   | ‚Üì Backward |
| **Steering wheel** | ‚Üê Left     | ‚óé Straight  | ‚Üí Right    |

## Giving the eyes to the car

Before our car will learn how to do self-parking using its muscles, it needs to be able to "see" the surroundings. Let's give it the `8` "eyes" in a form of distance sensors:

- Each sensor can detect the obstacle in a distance range of `0-4m` (meters).
- Each sensor "reports" the latest information about the obstacles it "sees" to the car's "brain" every `100ms`.
- Whenever the sensor doesn't "see" any obstacles it "reports" the value of `0`. On the contrary, if the value of the sensor is small but not zero (i.e. `0.01m`) it would mean that the obstacle is really close.

![Car sensors with distances](assets/04-sensors-01.jpg)

## Giving the brain to the car

At this moment, our car can "see" and "move", but there is no "coordinator" for it, that would transform the signals from the "eyes" to the proper movements of the "muscles" - we need to give the car a "brain".

## Evolving the car's brain















## Draft: weightedRandom

```typescript
// Picks the random item based on its weight.
// The items with higher weight will be picked more often.
const weightedRandom = <T>(items: T[], weights: number[]): { item: T, index: number } => {
  if (items.length !== weights.length) {
    throw new Error('Items and weights must be of the same size');
  }

  // Preparing the cumulative weights array.
  // For example:
  // - weights = [1, 4, 3]
  // - cumulativeWeights = [1, 5, 8]
  const cumulativeWeights: number[] = [];
  for (let i = 0; i < weights.length; i += 1) {
    cumulativeWeights[i] = weights[i] + (cumulativeWeights[i - 1] || 0);
  }

  // Getting the random number in a range [0...sum(weights)]
  // For example:
  // - weights = [1, 4, 3]
  // - maxCumulativeWeight = 8
  // - range for the random number is [0...8]
  const maxCumulativeWeight = cumulativeWeights[cumulativeWeights.length - 1];
  const randomNumber = maxCumulativeWeight * Math.random();

  // Picking the random item based on its weight.
  // The items with higher weight will be picked more often.
  for (let i = 0; i < items.length; i += 1) {
    if (cumulativeWeights[i] >= randomNumber) {
      return {
        item: items[i],
        index: i,
      };
    }
  }
  return {
    item: items[items.length - 1],
    index: items.length - 1,
  };
};
```

## Draft: Genetic Algorithm

Create car genome:

```typescript
type Gene = 0 | 1;

type Genome = Gene[];

function createGenome(length: number): Genome {
  return new Array(length)
    .fill(null)
    .map(() => (Math.random() < 0.5 ? 0 : 1));
}
```

Create generation:

```typescript
type Generation = Genome[];

type GenerationParams = {
  generationSize: number,
  genomeLength: number,
};

function createGeneration(params: GenerationParams): Generation {
  const { generationSize, genomeLength } = params;
  return new Array(generationSize)
    .fill(null)
    .map(() => createGenome(genomeLength));
}
```

Mutate:

```typescript
// The number between 0 and 1.
type Probability = number;

// @see: https://en.wikipedia.org/wiki/Mutation_(genetic_algorithm)
function mutate(genome: Genome, mutationProbability: Probability): Genome {
  // Conceive children.
  for (let geneIndex = 0; geneIndex < genome.length; geneIndex += 1) {
    const gene: Gene = genome[geneIndex];
    const mutatedGene: Gene = gene === 0 ? 1 : 0;
    genome[geneIndex] = Math.random() < mutationProbability ? mutatedGene : gene;
  }
  return genome;
}
```

Selection:

```typescript
// The number between 0 and 100.
type Percentage = number;

type SelectionOptions = {
  mutationProbability: Probability,
  longLivingChampionsPercentage: Percentage,
};

type FitnessFunction = (genome: Genome) => number;

// @see: https://en.wikipedia.org/wiki/Selection_(genetic_algorithm)
function select(
  generation: Generation,
  fitness: FitnessFunction,
  options: SelectionOptions,
) {
  const {
    mutationProbability,
    longLivingChampionsPercentage,
  } = options;

  const newGeneration: Generation = [];

  const oldGeneration = [...generation];
  // First one - the fittest one.
  oldGeneration.sort((genomeA: Genome, genomeB: Genome): number => {
    const fitnessA = fitness(genomeA);
    const fitnessB = fitness(genomeB);
    if (fitnessA < fitnessB) {
      return 1;
    }
    if (fitnessA > fitnessB) {
      return -1;
    }
    return 0;
  });

  // Let long-liver champions continue living in the new generation.
  const longLiversCount = Math.floor(longLivingChampionsPercentage * oldGeneration.length / 100);
  if (longLiversCount) {
    oldGeneration.slice(0, longLiversCount).forEach((longLivingGenome: Genome) => {
      newGeneration.push(longLivingGenome);
    });
  }

  // Get the data about he fitness of each individuum.
  const fitnessPerOldGenome: number[] = oldGeneration.map((genome: Genome) => fitness(genome));

  // Populate the next generation until it becomes the same size as a old generation.
  while (newGeneration.length < generation.length) {
    // Select random father and mother from the population.
    // The fittest individuums have higher chances to be selected.
    let father: Genome | null = null;
    let fatherGenomeIndex: number | null = null;
    let mother: Genome | null = null;
    let matherGenomeIndex: number | null = null;

    // To produce children the father and mother need each other.
    // It must be two different individuums.
    while (!father || !mother || fatherGenomeIndex === matherGenomeIndex) {
      const {
        item: randomFather,
        index: randomFatherGenomeIndex,
      } = weightedRandom<Genome>(generation, fitnessPerOldGenome);

      const {
        item: randomMother,
        index: randomMotherGenomeIndex,
      } = weightedRandom<Genome>(generation, fitnessPerOldGenome);

      father = randomFather;
      fatherGenomeIndex = randomFatherGenomeIndex;

      mother = randomMother;
      matherGenomeIndex = randomMotherGenomeIndex;
    }

    // Let father and mother produce two children.
    const [firstChild, secondChild] = mate(father, mother, mutationProbability);

    newGeneration.push(firstChild);

    // Depending on the number of long-living champions it is possible that
    // there will be the place for only one child, sorry.
    if (newGeneration.length < generation.length) {
      newGeneration.push(secondChild);
    }
  }

  return newGeneration;
}
```

## Draft: Euclidean distance

```typescript
type NumVec3 = [number, number, number];

// Calculates the XZ distance between two points in space.
// The vertical Y distance is not being taken into account.
const euclideanDistance = (from: NumVec3, to: NumVec3) => {
  const fromX = from[0];
  const fromZ = from[2];
  const toX = to[0];
  const toZ = to[2];
  return Math.sqrt((fromX - toX) ** 2 + (fromZ - toZ) ** 2);
};
```
