---

title: "Self-Parking Car in <500 Lines of Code"

summary: "Training the car to do self-parking using a genetic algorithm"

cover: assets/01-cover-00.jpg

date: 2021-09-18

---

![Self-Parking car evolution](assets/01-cover-01.jpg)

## TL;DR

In this article we'll train the car to do self-parking using a [genetic algorithm](https://en.wikipedia.org/wiki/Genetic_algorithm).

We'll create **the 1st generation** of cars with random genomes that will behave something like this:

![The 1st generation of cars with random genomes](assets/02-cars-before-01.gif)

**On the ≈40th generation** the cars start learning what the self-parking is and start getting closer to the parking spot:

![The 40th generation start learning how to park](assets/03-car-after-01.gif)

Another example with a bit more challenging starting point:

![More challenging starting point for self-parking](assets/03-car-after-03.gif)

> Yeah-yeah, the cars are hitting some other cars along the way, bit this is only the 40th generation since the creation of the world for them, so be merciful and give them some space to grow :D

You may launch the 🚕 [Self-parking Car Evolution Simulator](https://trekhleb.dev/self-parking-car-evolution) to see the evolution process directly in you browser. The simulator gives you the following opportunities:

- You may [train the cars from scratch](https://trekhleb.dev/self-parking-car-evolution?parking=evolution#/) and adjust genetic parameters by yourself
- You may [see the trained self-parking cars in action](https://trekhleb.dev/self-parking-car-evolution?parking=automatic#/)
- You may also [try to park the car manually](https://trekhleb.dev/self-parking-car-evolution?parking=manual#/).

The genetic algorithm for this project is implemented in TypeScript. The full genetic source code will be shown in this article, but you may also find the final code examples in the [Evolution Simulator repository](https://github.com/trekhleb/self-parking-car-evolution).

> We're going to use a genetic algorithm for particular task of evolving cars genomes. However, this article only touches on the basics of the algorithm and is by no means a complete guide to the genetic algorithm topic.

Having that said, let's deep dive into more details...

## The Plan

Here is what we're going to do:

1. 💪🏻 Give the **muscles** (engine, steering wheel) to the car so that it could move towards the parking lot.
2. 👀 Give the **eyes** (sensors) to the car so that they could see the obstacles around.
3. 🧠 Give the **brain** to the car that will control the muscles (movements) based on what car sees (obstacles via sensors). The brain is simply a pure function `movements = f(sensors)`.
4. 🧬 **Evolve/teach the brain** to do the right moves based on the sensors input. This is where we will apply a genetic algorithm. Generation after generation our brain function `movements = f(sensors)` will learn how to move the car towards the parking lot.

## Giving the muscles to the car

To be able to move, the car would need "muscles". Let's give the car two types of muscles:

1. **Engine muscle** - allows the car to move *↓ back*, *↑ forth*, or *◎ stand steel* (neutral gear)
2. **Steering wheel muscle** - allows the car to turn *← left*, *→ right*, or *◎ go straight* while moving

With these two muscles the car is able to perform the following movements:

![Car movements achieved by car muscles](assets/03-car-muscles-01.gif)

In our case, the muscles are receivers of the signals that comes from the brain once every `100ms` (milliseconds). Based on the value of the brain's signal the muscles acts differently. We'll cover the "brain" part below, but for now, let's say that our brain may send only 3 possible signals to each muscle: `-1`, `0`, or `+1`.

```typescript
type MuscleSignal = -1 | 0 | 1;
```

For example, the brain may send the signal with the value of `+1` to the engine muscle and it will start moving the car forward. The signal `-1` to the engine moves the car backward. At the same time, if the brain will send the signal of `-1` to the steering wheel muscle, it will turn the car to the left.

Here is how the brain signal values map to the muscle actions in our case:

| Muscle             | `Signal = -1` | `Signal = 0` | `Signal = +1` |
| :----------------- | :------------ | :----------- | :------------ |
| **Engine**         | ↓ Backward    | ◎ Neutral    | ↑ Forward     |
| **Steering wheel** | ← Left        | ◎ Straight   | → Right       |

> You may [use the Evolution Simulator](https://trekhleb.dev/self-parking-car-evolution?parking=manual#/) and try to park the car manually to see how car muscles work. Every time you press one of the `WASD` buttons (or use a joystick) you send these `-1`, `0` or `+1` signals to the engine and steering wheel muscles.

## Giving the eyes to the car

Before our car will learn how to do self-parking using its muscles, it needs to be able to "see" the surroundings. Let's give it the `8` eyes in a form of distance sensors:

- Each sensor can detect the obstacle in a distance range of `0-4m` (meters).
- Each sensor reports the latest information about the obstacles it "sees" to the car's "brain" every `100ms`.
- Whenever the sensor doesn't see any obstacles it reports the value of `0`. On the contrary, if the value of the sensor is small but not zero (i.e. `0.01m`) it would mean that the obstacle is really close.

![Car sensors with distances](assets/04-sensors-01.jpg)

> You may [use the Evolution Simulator](https://trekhleb.dev/self-parking-car-evolution?parking=manual#/) and see how the color of each sensor changes based on how close the obstacle is.

```typescript
type Sensors = number[];
```

## Giving the brain to the car

At this moment, our car can "see" and "move", but there is no "coordinator", that would transform the signals from the "eyes" to the proper movements of the "muscles". We need to give the car a "brain".

### Brain input

As an input from the sensors, every `100ms` the brain will be getting `8` float numbers, each one in range of `[0...4]`. For example, the input might look like this:

```typescript
const brainInput: Sensors = [s0, s1, s2, s3, s4, s5, s6, s7];
// i.e. 🧠 ← [0, 0.5, 4, 0.002, 0, 3.76, 0, 1.245]
```

### Brain output

Every `100ms` the brain should produce two integers as an output:

1. One number as a signal for the engine: `engineSignal`
2. One number as signal for the steering wheel: `wheelSignal`

Each number should be of a type `MuscleSignal` and might take one of three values: `-1`, `0`, or `+1`.

### Brain formulas/functions

Keeping in mind the brain's input and output mentioned above we may say that the brain is just a function:

```typescript
const brainInput: Sensors = [s0, s1, s2, s3, s4, s5, s6, s7];
const { engineSignal, wheelSignal } = brainFunction(brainInput);
// i.e. { engineSignal: 0, wheelSignal: -1 } ← 🧠 ← [0, 0.5, 4, 0.002, 0, 3.76, 0, 1.245]
```

The main question now is what kind of function the `brainFunction()` is.

To make the car smarter and its movements to be more sophisticated we could go with a [Multilayer Perceptron](https://en.wikipedia.org/wiki/Multilayer_perceptron). The name is a bit scary but this is a simple Neural Network with a basic architecture (think of it as of a big formula with many parameters/coefficients).

> I've covered Multilayer Perceptrons with a bit more details in my [homemade-machine-learning](https://github.com/trekhleb/homemade-machine-learning#-multilayer-perceptron-mlp), [machine-learning-experiments](https://github.com/trekhleb/machine-learning-experiments#multilayer-perceptron-mlp-or-simple-neural-network-nn), and [nano-neuron](https://github.com/trekhleb/nano-neuron) projects. You may even challenge that simple network [to recognize your written digits](https://trekhleb.dev/machine-learning-experiments/#/experiments/DigitsRecognitionMLP).

However, to avoid the introduction of a whole new concept of Neural Networks, we'll go with a much simpler approach and we'll use two **Linear Polynomials** with multiple variables (to be precise, with exactly `8` variables, since we have `8` sensors) which will look something like this:

```typescript
engineSignal ← (e0 * s0) + (e1 * s1) + ... + (e7 * s7) + e8
wheelSignal ← (w0 * s0) + (w1 * s1) + ... + (w7 * s7) + w8
```

Where:

- `[s0, s1, ..., s7]` - the `8` variables (`8` sensor values)
- `[e0, e1, ..., e8]` - the `9` coefficients for the engine polynomial
- `[w0, w1, ..., w8]` - the `9` coefficients for the steering wheel polynomial

The cost of using the simpler function for the brain will be that the car won't be able to learn some sophisticated moves and also won't be able to generalize well and to adopt well to the unknown surroundings. But for our particular parking lot and for the sake of demonstrating the work of a genetic algorithm it should still be enough.

> When we say that the car will evolve and learn how to do the self-parking, we mean that the car will figure out the "good-enough" values for these `18` coefficients (`9 + 9`), that will help it to do the parking.

> The values of these `[e0, e1, ..., e8]` and `[w0, w1, ..., w8]` coefficients will be the core and the essence of the car. These `18` numbers will define unique car's abilities and behavior. It is like a genome or a DNA for the human.

We may implement the generic polynomial function in the following way:

```typescript
type Coefficients = number[];

const linearPolynomial = (coefficients: Coefficients, variables: number[]): number => {
  if (coefficients.length !== (variables.length + 1)) {
    throw new Error('Incompatible number of polynomial coefficients and variables');
  }
  let result = 0;
  coefficients.forEach((coefficient: number, coefficientIndex: number) => {
    if (coefficientIndex < variables.length) {
      result += coefficient * variables[coefficientIndex];
    } else {
      result += coefficient
    }
  });
  return result;
};
```

The car's "brain" in this case will consist of two polynomials and will look like this:

```typescript
const engineSignal: MuscleSignal = linearPolynomial(engineCoefficients, sensors);
const wheelSignal: MuscleSignal = linearPolynomial(wheelCoefficients, sensors);
```

## Evolving the car's brain
